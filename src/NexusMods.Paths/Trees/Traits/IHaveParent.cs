using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using NexusMods.Paths.HighPerformance.CommunityToolkit;

namespace NexusMods.Paths.Trees.Traits;

/// <summary>
///     An interface used by FileTree implementations to indicate that they have a parent.
/// </summary>
/// <typeparam name="TSelf">The concrete type stored inside this interface.</typeparam>
public interface IHaveParent<TSelf> where TSelf : struct, IHaveParent<TSelf>
{
    /// <summary>
    ///     Returns the parent node if it exists. If not, the node is considered the root node.
    /// </summary>
    public ParentBox<TSelf>? Parent { get; }

    /// <summary>
    ///     Returns true if the tree has a parent.
    /// </summary>
    bool HasParent => Parent != null;

    /// <summary>
    ///     Returns true if this is the root of the tree.
    /// </summary>
    bool IsTreeRoot => !HasParent;
}

/// <summary>
///     A boxed element that implements <see cref="IHaveBoxedChildren{TSelf}" />
/// </summary>
/// <remarks>
///     This is a helper class that boxes a constrained generic structure type.
///     While generic reference types share code (and are thus slower),
///     Generic structures can participate in devirtualization, and thus create
///     zero overhead abstractions.
/// </remarks>
[ExcludeFromCodeCoverage]
public class ParentBox<TSelf> : IEquatable<ParentBox<TSelf>> where TSelf : struct, IHaveParent<TSelf>
{
    /// <summary>
    ///     Contains item deriving from <see cref="IHaveBoxedChildren{TSelf}" />
    /// </summary>
    public TSelf Item;

    /// <summary />
    public static implicit operator TSelf(ParentBox<TSelf> box) => box.Item;

    /// <summary />
    public static implicit operator ParentBox<TSelf>(TSelf item) => new() { Item = item };

    #region Autogenerated by R#
    /// <inheritdoc />
    public bool Equals(ParentBox<TSelf>? other)
    {
        if (ReferenceEquals(null, other)) return false;
        if (ReferenceEquals(this, other)) return true;
        return Item.Equals(other.Item);
    }

    /// <inheritdoc />
    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != this.GetType()) return false;
        return Equals((ParentBox<TSelf>)obj);
    }

    /// <inheritdoc />
    // ReSharper disable once NonReadonlyMemberInGetHashCode
    public override int GetHashCode() => Item.GetHashCode();
    #endregion
}

/// <summary>
///     Trait methods for <see cref="IHaveBoxedChildren{TSelf}" />.
/// </summary>
// ReSharper disable once InconsistentNaming
public static class IHaveParentExtensionsForIHaveBoxedChildren
{
    /// <summary>
    ///      Returns the total number of siblings in this node.
    /// </summary>
    /// <param name="item">The 'this' item.</param>
    /// <returns>The total amount of siblings.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingCount<TSelf>(this ChildBox<TSelf> item)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>
        => item.Item.GetSiblingCount();

    /// <summary>
    ///      Returns the total number of siblings in this node.
    /// </summary>
    /// <param name="item">The 'this' item.</param>
    /// <returns>The total amount of siblings.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingCount<TSelf>(this TSelf item)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>
    {
        var parent = item.Parent;
        if (parent != null) // <= do not invert branch, hot path
            return parent.Item.Children.Length - 1; // -1 to exclude self.

        return 0;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChildBox<TSelf>[] GetSiblings<TSelf>(this ChildBox<TSelf> item)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var result = GC.AllocateUninitializedArray<ChildBox<TSelf>>(item.GetSiblingCount());
        GetSiblingsUnsafe(item, result);
        return result;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChildBox<TSelf>[] GetSiblings<TSelf>(this TSelf item)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var result = GC.AllocateUninitializedArray<ChildBox<TSelf>>(item.GetSiblingCount());
        GetSiblingsUnsafe(item, result);
        return result;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <param name="resultsBuf">
    ///     The buffer which holds the results.
    ///     Please use <see cref="GetSiblingCount{TSelf}(NexusMods.Paths.Trees.Traits.ChildBox{TSelf})"/> to obtain the required size.
    /// </param>
    /// <returns>The amount of siblings inserted into the buffer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingsUnsafe<TSelf>(this ChildBox<TSelf> item, Span<ChildBox<TSelf>> resultsBuf)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        // Note: While this code is mostly duplicated from other overload, it is not the same.
        //       This compares reference equality, other compares value equality.
        var parent = item.Item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            var writeIndex = 0;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Equals(item))
                    resultsBuf.DangerousGetReferenceAt(writeIndex++) = child;
            }

            return item.GetSiblingCount();
        }

        return 0;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <param name="resultsBuf">
    ///     The buffer which holds the results.
    ///     Please use <see cref="GetSiblingCount{TSelf}(NexusMods.Paths.Trees.Traits.ChildBox{TSelf})"/> to obtain the required size.
    /// </param>
    /// <returns>The amount of siblings inserted into the buffer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingsUnsafe<TSelf>(this TSelf item, Span<ChildBox<TSelf>> resultsBuf)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var parent = item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            var writeIndex = 0;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Item.Equals(item))
                    resultsBuf.DangerousGetReferenceAt(writeIndex++) = child;
            }

            return item.GetSiblingCount();
        }

        return 0;
    }

    /// <summary>
    ///      Enumerates all of the siblings of this node.
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<ChildBox<TSelf>> EnumerateSiblings<TSelf>(this ChildBox<TSelf> item)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        // Note: While this code is mostly duplicated from other overload, it is not the same.
        //       This compares reference equality, other compares value equality.
        var parent = item.Item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Equals(item))
                    yield return child;
            }
        }
    }

    /// <summary>
    ///      Enumerates all of the siblings of this node.
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<ChildBox<TSelf>> EnumerateSiblings<TSelf>(this TSelf item)
        where TSelf : struct, IHaveBoxedChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var parent = item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Item.Equals(item))
                    yield return child;
            }
        }
    }
}

/// <summary>
///     Trait methods for <see cref="IHaveObservableChildren{TSelf}" />.
/// </summary>
// ReSharper disable once InconsistentNaming
public static class IHaveParentExtensionsForIHaveObservableChildren
{
    /// <summary>
    ///      Returns the total number of siblings in this node.
    /// </summary>
    /// <param name="item">The 'this' item.</param>
    /// <returns>The total amount of siblings.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingCount<TSelf>(this ChildBox<TSelf> item)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>
        => item.Item.GetSiblingCount();

    /// <summary>
    ///      Returns the total number of siblings in this node.
    /// </summary>
    /// <param name="item">The 'this' item.</param>
    /// <returns>The total amount of siblings.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingCount<TSelf>(this TSelf item)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>
    {
        var parent = item.Parent;
        if (parent != null) // <= do not invert branch, hot path
            return parent.Item.Children.Count - 1; // -1 to exclude self.

        return 0;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChildBox<TSelf>[] GetSiblings<TSelf>(this ChildBox<TSelf> item)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var result = GC.AllocateUninitializedArray<ChildBox<TSelf>>(item.GetSiblingCount());
        GetSiblingsUnsafe(item, result);
        return result;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChildBox<TSelf>[] GetSiblings<TSelf>(this TSelf item)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var result = GC.AllocateUninitializedArray<ChildBox<TSelf>>(item.GetSiblingCount());
        GetSiblingsUnsafe(item, result);
        return result;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <param name="resultsBuf">
    ///     The buffer which holds the results.
    ///     Please use <see cref="GetSiblingCount{TSelf}(NexusMods.Paths.Trees.Traits.ChildBox{TSelf})"/> to obtain the required size.
    /// </param>
    /// <returns>The amount of siblings inserted into the buffer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingsUnsafe<TSelf>(this ChildBox<TSelf> item, Span<ChildBox<TSelf>> resultsBuf)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        // Note: While this code is mostly duplicated from other overload, it is not the same.
        //       This compares reference equality, other compares value equality.
        var parent = item.Item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            var writeIndex = 0;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Equals(item))
                    resultsBuf.DangerousGetReferenceAt(writeIndex++) = child;
            }

            return item.GetSiblingCount();
        }

        return 0;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <param name="resultsBuf">
    ///     The buffer which holds the results.
    ///     Please use <see cref="GetSiblingCount{TSelf}(NexusMods.Paths.Trees.Traits.ChildBox{TSelf})"/> to obtain the required size.
    /// </param>
    /// <returns>The amount of siblings inserted into the buffer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingsUnsafe<TSelf>(this TSelf item, Span<ChildBox<TSelf>> resultsBuf)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var parent = item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            var writeIndex = 0;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Item.Equals(item))
                    resultsBuf.DangerousGetReferenceAt(writeIndex++) = child;
            }

            return item.GetSiblingCount();
        }

        return 0;
    }

    /// <summary>
    ///      Enumerates all of the siblings of this node.
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<ChildBox<TSelf>> EnumerateSiblings<TSelf>(this ChildBox<TSelf> item)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        // Note: While this code is mostly duplicated from other overload, it is not the same.
        //       This compares reference equality, other compares value equality.
        var parent = item.Item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Equals(item))
                    yield return child;
            }
        }
    }

    /// <summary>
    ///      Enumerates all of the siblings of this node.
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<ChildBox<TSelf>> EnumerateSiblings<TSelf>(this TSelf item)
        where TSelf : struct, IHaveObservableChildren<TSelf>, IHaveParent<TSelf>, IEquatable<TSelf>
    {
        var parent = item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Item.Equals(item))
                    yield return child;
            }
        }
    }
}

/// <summary>
///     Trait methods for <see cref="IHaveBoxedChildrenWithKey{TKey,TSelf}" />.
/// </summary>
// ReSharper disable once InconsistentNaming
public static class IHaveParentExtensionsForIHaveBoxedChildrenWithKey
{
    /// <summary>
    ///      Returns the total number of siblings in this node.
    /// </summary>
    /// <param name="item">The 'this' item.</param>
    /// <returns>The total amount of siblings.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingCount<TSelf, TKey>(this ChildWithKeyBox<TKey, TSelf> item)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf> where TKey : notnull
        => item.Item.GetSiblingCount<TSelf, TKey>();

    /// <summary>
    ///      Returns the total number of siblings in this node.
    /// </summary>
    /// <param name="item">The 'this' item.</param>
    /// <returns>The total amount of siblings.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingCount<TSelf, TKey>(this TSelf item)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf> where TKey : notnull
    {
        var parent = item.Parent;
        if (parent != null) // <= do not invert branch, hot path
            return parent.Item.Children.Count - 1; // -1 to exclude self.

        return 0;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChildWithKeyBox<TKey, TSelf>[] GetSiblings<TSelf, TKey>(this TSelf item)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf>, IEquatable<TSelf> where TKey : notnull
    {
        var count = item.GetSiblingCount<TSelf, TKey>();
        var result = GC.AllocateUninitializedArray<ChildWithKeyBox<TKey, TSelf>>(count);
        GetSiblingsUnsafe<TSelf, TKey>(item, result);
        return result;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <param name="resultsBuf">
    ///     The buffer which holds the results.
    ///     Please use <see cref="GetSiblingCount{TSelf,TKey}(TSelf)"/> to obtain the required size.
    /// </param>
    /// <returns>The amount of siblings inserted into the buffer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingsUnsafe<TSelf, TKey>(this TSelf item, Span<ChildWithKeyBox<TKey, TSelf>> resultsBuf)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf>, IEquatable<TSelf> where TKey : notnull
    {
        var parent = item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            var writeIndex = 0;
            foreach (var child in parentChildren)
            {
                if (!child.Value.Item.Equals(item))
                    resultsBuf.DangerousGetReferenceAt(writeIndex++) = child.Value;
            }

            return item.GetSiblingCount<TSelf, TKey>();
        }

        return 0;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ChildWithKeyBox<TKey, TSelf>[] GetSiblings<TSelf, TKey>(this ChildWithKeyBox<TKey, TSelf> item)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf>, IEquatable<TSelf> where TKey : notnull
    {
        var count = item.GetSiblingCount();
        var result = GC.AllocateUninitializedArray<ChildWithKeyBox<TKey, TSelf>>(count);
        GetSiblingsUnsafe(item, result);
        return result;
    }

    /// <summary>
    ///      Returns all of the siblings of this node (excluding itself).
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <param name="resultsBuf">
    ///     The buffer which holds the results.
    ///     Please use <see cref="GetSiblingCount{TSelf,TKey}(TSelf)"/> to obtain the required size.
    /// </param>
    /// <returns>The amount of siblings inserted into the buffer.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSiblingsUnsafe<TSelf, TKey>(this ChildWithKeyBox<TKey, TSelf> item, Span<ChildWithKeyBox<TKey, TSelf>> resultsBuf)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf>, IEquatable<TSelf> where TKey : notnull
    {
        var parent = item.Item.Parent;

        // Note: While this code is mostly duplicated from other overload, it is not the same.
        //       This compares reference equality, other compares value equality.
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            var writeIndex = 0;
            foreach (var child in parentChildren)
            {
                if (!child.Value.Equals(item))
                    resultsBuf.DangerousGetReferenceAt(writeIndex++) = child.Value;
            }

            return item.GetSiblingCount();
        }

        return 0;
    }

    /// <summary>
    ///      Enumerates all of the siblings of this node.
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<ChildWithKeyBox<TKey, TSelf>> EnumerateSiblings<TSelf, TKey>(this TSelf item)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf>, IEquatable<TSelf> where TKey : notnull
    {
        var parent = item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Value.Item.Equals(item))
                    yield return child.Value;
            }
        }
    }

    /// <summary>
    ///      Enumerates all of the siblings of this node.
    /// </summary>
    /// <param name="item">The item whose siblings to obtain.</param>
    /// <returns>All of the siblings of this node.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<ChildWithKeyBox<TKey, TSelf>> EnumerateSiblings<TSelf, TKey>(this ChildWithKeyBox<TKey, TSelf> item)
        where TSelf : struct, IHaveBoxedChildrenWithKey<TKey, TSelf>, IHaveParent<TSelf>, IEquatable<TSelf> where TKey : notnull
    {
        var parent = item.Item.Parent;
        // ReSharper disable once InvertIf
        if (parent != null) // <= do not invert, hot path.
        {
            var parentChildren = parent.Item.Children;
            foreach (var child in parentChildren) // <= lowered to 'for'
            {
                if (!child.Value.Equals(item))
                    yield return child.Value;
            }
        }
    }
}

/// <summary>
///     Trait methods for <see cref="IHaveParent{TSelf}"/>.
/// </summary>
// ReSharper disable once InconsistentNaming
public static class IHaveParentExtensions
{
    /// <summary>
    ///      Returns true if the tree has a parent.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool HasParent<TSelf>(this TSelf item)
        where TSelf : struct, IHaveParent<TSelf>
        => item.HasParent;

    /// <summary>
    ///      Returns true if this is the root of the tree.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsTreeRoot<TSelf>(this TSelf item)
        where TSelf : struct, IHaveParent<TSelf>
        => item.IsTreeRoot;
}
